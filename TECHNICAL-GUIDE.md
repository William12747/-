# 視頻轉檔工具 - 技術指南

## 目錄
1. [核心概念](#核心概念)
2. [為什麼能轉檔](#為什麼能轉檔)
3. [技術架構](#技術架構)
4. [為什麼需要這些技術](#為什麼需要這些技術)
5. [隊列機制](#隊列機制)
6. [掃描視頻過程](#掃描視頻過程)
7. [轉換的完整步驟](#轉換的完整步驟)
8. [技術棧總結](#技術棧總結)
9. [為什麼需要新增檔案才能轉檔](#為什麼需要新增檔案才能轉檔)
10. [完整工作流程示例](#完整工作流程示例)

---

## 核心概念

### 這個工具是什麼？

這是一個**桌面應用**，用於將舊格式的視頻文件（如 .flv, .wmv, .avi, .3gp 等）**批量轉換**成現代通用的 MP4 格式。

### 適用場景

- 轉換多個舊格式視頻為 MP4
- 批量處理大量視頻文件
- 在本地進行離線轉換
- 需要監控轉換進度

---

## 為什麼能轉檔

### FFmpeg - 轉檔的核心

本工具真正進行轉檔工作的是 **FFmpeg** - 一個強大的開源視頻轉碼工具。

#### FFmpeg 的三大功能：

| 功能 | 說明 |
|------|------|
| **📖 讀取** | 讀取各種舊格式視頻 (`.flv`, `.wmv`, `.avi`, `.3gp` 等) |
| **🔄 轉碼** | 將視頻轉換為現代格式 (`.mp4`) |
| **💾 編碼** | 使用高效的編碼器 (H.264 視頻 + AAC 音頻) |

#### 工作原理

```
輸入視頻 (任意格式)
    ↓
FFmpeg 解碼 (理解舊格式)
    ↓
H.264 編碼 (轉換為 MP4 格式)
    ↓
AAC 音頻編碼 (高品質音頻)
    ↓
輸出 MP4 文件 ✅
```

**類比**：就像一台萬能翻譯機，能把各種書籍翻譯成統一的英文版本。

---

## 技術架構

### 分層架構圖

```
┌─────────────────────────────────────────┐
│         前端 (UI 層) - React            │
│  ┌──────────────────────────────────┐   │
│  │ React 組件                       │   │
│  │ - App.js (主應用)               │   │
│  │ - FolderSelector (選擇資料夾)   │   │
│  │ - ControlPanel (開始/暫停按鈕)  │   │
│  │ - QueueList (隊列顯示)          │   │
│  │ - LogViewer (日誌查看)          │   │
│  │ - PreviewPlayer (預覽播放)      │   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
                    ↓
        IPC 通道 (前端 ↔ 後端)
                    ↓
┌─────────────────────────────────────────┐
│      後端 (Electron 主進程)             │
│  ┌──────────────────────────────────┐   │
│  │ main.js - 應用主進程             │   │
│  │ - 管理應用窗口                   │   │
│  │ - 轉發 IPC 命令                  │   │
│  │ - 調用 VideoProcessor           │   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│     核心轉檔引擎                        │
│  ┌──────────────────────────────────┐   │
│  │ videoProcessor.js                │   │
│  │ - 掃描視頻文件                   │   │
│  │ - 調用 FFmpeg 轉檔              │   │
│  │ - 監控轉換進度                   │   │
│  └──────────────────────────────────┘   │
│  ┌──────────────────────────────────┐   │
│  │ FFmpeg 引擎                      │   │
│  │ - 實際進行視頻轉碼              │   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│       檔案系統                          │
│  ┌──────────────────────────────────┐   │
│  │ 輸入資料夾   →   輸出資料夾     │   │
│  │ 源視頻文件   →   MP4 文件       │   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### 通信流程

```
React UI (前端)
    ↓ (用戶操作：點擊按鈕)
preload.js (安全橋接)
    ↓ (ipcRenderer 發送)
main.js (Electron 主進程)
    ↓ (ipcMain 接收)
videoProcessor.js (轉檔引擎)
    ↓ (調用)
FFmpeg (視頻轉碼)
    ↓ (完成)
main.js (返回結果)
    ↓ (ipcMain 響應)
preload.js (發送回前端)
    ↓ (事件監聽)
React UI (更新顯示) ✅
```

---

## 為什麼需要這些技術

### 1. Electron（桌面應用框架）

#### 為什麼不直接用網頁？

| 需求 | 網頁 | Electron |
|------|------|----------|
| 訪問用戶文件系統 | ❌ 不行（安全限制） | ✅ 可以 |
| 運行 FFmpeg 等系統工具 | ❌ 不行 | ✅ 可以 |
| 複雜後台轉碼操作 | ❌ 不行 | ✅ 可以 |
| 離線使用 | ❌ 需要網絡 | ✅ 可以 |
| 系統通知/托盤集成 | ❌ 有限 | ✅ 完全支持 |

**類比**：Electron = 在您的電腦上運行的瀏覽器

#### Electron 的雙進程架構

```
┌──────────────────────────────┐
│    主進程 (Main Process)      │
│  - 管理應用窗口              │
│  - 訪問文件系統              │
│  - 運行 FFmpeg              │
│  - 系統級操作                │
└──────────────────────────────┘
            ↕ IPC
┌──────────────────────────────┐
│   渲染進程 (Renderer)         │
│  - React UI 搖在這裡         │
│  - 用戶交互                  │
│  - 顯示結果                  │
└──────────────────────────────┘
```

### 2. React（UI 框架）

#### 為什麼需要？

- 🎨 **搭建漂亮的界面** - 按鈕、表單、列表、進度條
- 🔄 **實時更新** - 隊列變化時立即刷新顯示
- ⚡ **高效渲染** - 只更新變化的部分，不重新渲染整個頁面
- 📱 **組件化** - 把 UI 分成可重用的組件

#### React 組件結構

```
App.js (主應用)
├── FolderSelector (選擇資料夾)
├── ControlPanel (開始/暫停按鈕)
├── QueueList (顯示轉換隊列)
│   └── VideoItem (每個視頻項目)
├── LogViewer (實時日誌)
└── PreviewPlayer (視頻預覽)
```

### 3. IPC（進程間通信）

#### 為什麼需要？

前端（React）和後端（FFmpeg）運行在不同進程中，需要通信：

```
前端請求: "請幫我轉這個視頻"
    ↓
IPC 通道 (信息傳遞)
    ↓
後端執行: FFmpeg 開始轉碼
    ↓
IPC 通道 (結果返回)
    ↓
前端更新: "轉碼完成！"
```

#### IPC 調用示例

```javascript
// 前端 (React)
const result = await window.electronAPI.convertVideo({
  inputPath: '/videos/old.flv',
  outputPath: '/output/new.mp4'
});

// 後端 (main.js) 接收並處理
ipcMain.handle('convert-video', async (event, { inputPath, outputPath }) => {
  // 調用 FFmpeg 進行轉碼
  console.log(`轉碼: ${inputPath} → ${outputPath}`);
  // ...返回結果
});
```

### 4. Logger（日誌系統）

#### 為什麼需要？

- 🐛 **調試問題** - 出錯時有詳細日誌
- 📊 **監控進度** - 看到每個轉碼步驟
- 💾 **持久化** - 保存到文件以備查閱
- 📱 **實時顯示** - UI 中即時更新日誌

---

## 隊列機制

### 為什麼需要隊列？

#### ❌ 不用隊列（同時轉換）

```
同時啟動 10 個 FFmpeg 進程
    ↓
CPU 100% | 內存滿載 | 硬盤超負荷
    ↓
電腦卡死或轉碼質量下降
```

#### ✅ 使用隊列（順序轉換）

```
隊列: [視頻1(轉換中), 視頻2(等待), 視頻3(等待), ...]
    ↓ 視頻1 完成 (30 秒)
隊列: [視頻1(✅完成), 視頻2(轉換中), 視頻3(等待), ...]
    ↓ 視頻2 完成 (45 秒)
隊列: [視頻1(✅完成), 視頻2(✅完成), 視頻3(轉換中), ...]
    ↓ 視頻3 完成 (60 秒)
隊列: [視頻1(✅完成), 視頻2(✅完成), 視頻3(✅完成), ...]
```

### 隊列狀態機制

```
QUEUED (等待中)
   ↓
PROCESSING (轉換中)
   ├─→ COMPLETED (✅ 成功)
   └─→ FAILED (❌ 失敗)
```

### 隊列優點

| 優點 | 說明 |
|------|------|
| **穩定** | 一次只轉一個，系統負荷穩定 |
| **可控** | 可隨時暫停/繼續 |
| **靈活** | 可新增或移除隊列中的項目 |
| **高效** | 充分利用系統資源但不過載 |
| **易監控** | 清楚看到每個視頻的轉換狀態 |

---

## 掃描視頻過程

### 完整的掃描流程

```
用戶點「掃描影片檔案」
    ↓
前端調用: window.electronAPI.scanFolder(folderPath)
    ↓
IPC 發送掃描請求到後端
    ↓
後端 (main.js) 調用: scanFolder(folderPath)
    ↓
遞歸掃描所有子目錄
    │
    ├─ 加載目錄中的所有文件
    ├─ 逐一檢查每個文件的副檔名
    ├─ 與 SUPPORTED_FORMATS 列表比對
    │   SUPPORTED_FORMATS = ['.flv', '.avi', '.wmv', '.3gp', ...]
    ├─ 符合格式？→ 添加到結果
    └─ 不符合？→ 跳過
    ↓
返回找到的所有視頻文件列表
    ↓
IPC 發送結果回前端
    ↓
React 更新隊列顯示所有找到的視頻
```

### 支援的格式列表

```javascript
const SUPPORTED_FORMATS = [
  '.flv',     // Flash 視頻
  '.asf',     // Advanced Systems Format
  '.rmvb',    // RealMedia 視頻
  '.mpeg',    // MPEG 視頻
  '.mpg',     // MPEG 視頻（縮寫）
  '.wmv',     // Windows Media 視頻
  '.avi',     // Audio Video Interleave
  '.3gp',     // 3GPP 視頻
  '.3gpp'     // 3GPP 視頻（變體）
];
```

### 為什麼要遞歸掃描？

```
D:\影片\
├── 老電影.flv ✅ 找到
├── 手機視頻.3gp ✅ 找到
├── 照片.jpg ❌ 跳過
└── 2024年\
    ├── 家庭影片.wmv ✅ 找到
    └── 旅遊\
        └── 海邊.flv ✅ 找到
```

不遞歸 = 只掃最上層，會漏掉子目錄中的視頻

---

## 轉換的完整步驟

### 六個檢查點

每一個視頻轉換都會經過 6 個檢查點確保成功：

#### 檢查點 1: 驗證輸入參數
```
目的: 確保有有效的文件路徑
檢查:
  ✓ inputPath 不為空
  ✓ outputPath 不為空
  ✓ 路徑格式有效
```

#### 檢查點 2: 檢查輸入文件
```
目的: 確認要轉檔的視頻文件存在
檢查:
  ✓ 文件存在 (fs.existsSync)
  ✓ 文件可讀 (fs.accessSync)
  ✓ 不是只讀或受保護的
```

#### 檢查點 3: 準備輸出目錄
```
目的: 確保輸出資料夾存在
檢查:
  ✓ 輸出目錄是否存在
  ✓ 如果不存在，自動創建 (fs.mkdirSync)
  ✓ 有寫入權限
```

#### 檢查點 4: 使用 FFprobe 掃描
```
目的: 獲取視頻的詳細信息
掃描內容:
  ✓ 視頻時長 (duration)
  ✓ 檔案大小 (size)
  ✓ 比特率 (bitrate)
  ✓ 分辨率 (width x height)
  ✓ 編碼格式 (codec)
  ✓ 幀率 (fps)
```

#### 檢查點 5: 啟動 FFmpeg 轉码
```
目的: 開始實際的視頻轉碼
過程:
  1. 啟動 FFmpeg 進程
  2. 設置編碼參數:
     - 視頻編碼: H.264 (libx264)
     - 速度: fast (編碼速度)
     - 品質: CRF 22 (壓縮率)
     - 音頻編碼: AAC
     - 音頻位元率: 192k
  3. 監控進度
  4. 實時返回進度信息
```

#### 檢查點 6: 驗證輸出
```
目的: 確認 MP4 文件成功生成
檢查:
  ✓ 輸出文件存在 (fs.existsSync)
  ✓ 文件大小 > 0 (不是空文件)
  ✓ 可讀 (fs.accessSync)
```

### 視覺化流程

```
輸入: 港女吹.flv (10.45 MB)
 ↓
[檢查點 1] ✅ 參數有效
 ↓
[檢查點 2] ✅ 文件存在且可讀
 ↓
[檢查點 3] ✅ 輸出目錄準備就緒
 ↓
[檢查點 4] ✅ 視頻信息掃描完成
     - 時長: 163 秒
     - 分辨率: 1920x1080
 ↓
[檢查點 5] ✅ FFmpeg 轉碼進行中
     進度: 0% → 25% → 50% → 75% → 100%
     耗時: ~30 秒
 ↓
[檢查點 6] ✅ 輸出文件驗證成功
     港女吹.mp4 (17.47 MB) ✅
```

---

## 技術棧總結

| 層級 | 技術 | 版本 | 用途 |
|------|------|------|------|
| **UI 層** | React | 18.2.0 | 用戶介面和交互 |
| **UI 層** | react-scripts | 5.0.1 | 開發伺服器和打包 |
| **應用層** | Electron | 27.0.0 | 桌面應用容器 |
| **應用層** | Node.js | 內置 | 運行環境 |
| **轉碼層** | FFmpeg | 系統安裝 | 視頻編碼引擎 |
| **轉碼層** | fluent-ffmpeg | 2.1.2 | FFmpeg Node.js 套件 |
| **工具層** | FFprobe | 3.1.0 | 視頻信息提取 |
| **包管理** | npm | 內置 | 依賴管理 |

### 各層職責

```
React (UI層)
└─ 負責: 用戶界面、按鈕、表單、列表顯示

    ↓ IPC 通信

Electron (應用層)
└─ 負責: 窗口管理、系統集成、進程管理

    ↓ 調用

Node.js (運行環境)
└─ 負責: 文件系統操作、系統命令執行

    ↓ 調用

FFmpeg (轉碼層)
└─ 負責: 實際視頻轉碼、格式轉換、編碼
```

---

## 為什麼需要新增檔案才能轉檔

### 場景：添加 .3gp 格式支持

#### ❌ 不更新代碼

```javascript
// 原始: 不支持 .3gp
const SUPPORTED_FORMATS = ['.flv', '.avi', '.wmv', ...];

掃描流程:
我是 3gp 文件 → 檢查副檔名 → .3gp 在列表中嗎?
                           → 不在! → 跳過 ❌
結果: 看不到 .3gp 文件，無法轉檔
```

#### ✅ 更新代碼

```javascript
// 更新: 添加 .3gp 支持
const SUPPORTED_FORMATS = ['.flv', '.avi', '.wmv', ..., '.3gp'];

掃描流程:
我是 3gp 文件 → 檢查副檔名 → .3gp 在列表中嗎?
                           → 在! → 添加到隊列 ✅
結果: 看得到 .3gp 文件，可以轉檔
```

### 代碼修改位置

**文件**: `electron/videoProcessor.js`

```javascript
// 第 13 行
const SUPPORTED_FORMATS = ['.flv', '.asf', '.rmvb', '.mpeg', '.mpg', '.wmv', '.avi', '.3gp', '.3gpp'];
```

### 添加新格式的步驟

1. **識別問題**：看不到某種視頻格式
2. **查找位置**：打開 `videoProcessor.js`
3. **添加副檔名**：在 `SUPPORTED_FORMATS` 陣列中新增
4. **重啟應用**：刷新瀏覽器或重新啟動
5. **測試掃描**：再次掃描應該能看到新格式

### 支援的編碼格式與副檔名

```
H.264 編碼 (最常用):
  ✓ .mp4, .m4v

MPEG-4 編碼:
  ✓ .mpeg, .mpg

Flash 視頻:
  ✓ .flv

Windows Media:
  ✓ .wmv, .asf

Audio Video Interleave:
  ✓ .avi

RealMedia:
  ✓ .rmvb

3G 手機視頻:
  ✓ .3gp, .3gpp
```

---

## 完整工作流程示例

### 真實場景

您有一個包含舊視頻的資料夾結構：

```
D:\影片\
├── 老電影.flv (10.45 MB)
├── 家庭\
│   └── 婚禮.wmv (50 MB)
├── 手機\
│   └── 短影片.3gp (5 MB)
├── 照片.jpg (忽略)
└── 文檔.txt (忽略)
```

### 第 1 步：選擇輸入資料夾

```
用戶點擊「選擇資料夾」
    ↓
打開文件夾對話框
    ↓
用戶選擇: D:\影片\
    ↓
前端顯示: 📁 D:\影片\
```

**代碼流程**：
```javascript
// 前端 (React)
const handleSelectInputFolder = async () => {
  const folder = await window.electronAPI.selectFolder();
  setInputFolder(folder);
};

// 後端 (main.js)
ipcMain.handle('select-folder', async () => {
  const result = await dialog.showOpenDialog(mainWindow, {
    properties: ['openDirectory']
  });
  return result.filePaths[0];
});
```

### 第 2 步：掃描影片文件

```
用戶點擊「掃描影片檔案」
    ↓
App.js 調用 window.electronAPI.scanFolder('D:\影片\')
    ↓
main.js 接收 'scan-folder' 命令
    ↓
videoProcessor.scanFolder() 開始遞歸掃描
    ├─ 掃描 D:\影片\ 
    │   ├─ 老電影.flv ✅ (副檔名在 SUPPORTED_FORMATS 中)
    │   ├─ 照片.jpg ❌ (不是視頻格式)
    │   └─ 文檔.txt ❌ (不是視頻格式)
    ├─ 掃描 D:\影片\家庭\ 
    │   └─ 婚禮.wmv ✅ (副檔名在 SUPPORTED_FORMATS 中)
    └─ 掃描 D:\影片\手機\ 
        └─ 短影片.3gp ✅ (副檔名在 SUPPORTED_FORMATS 中)
    ↓
返回 3 個視頻文件到前端
    ↓
React 添加到隊列狀態
    ↓
UI 顯示隊列列表:
    [1] 老電影.flv (10.45 MB) - QUEUED ⏳
    [2] 婚禮.wmv (50 MB) - QUEUED ⏳
    [3] 短影片.3gp (5 MB) - QUEUED ⏳
```

### 第 3 步：選擇輸出資料夾

```
用戶點擊「選擇輸出資料夾」
    ↓
用戶選擇: D:\轉換完成\
    ↓
前端顯示: 📁 D:\轉換完成\
```

### 第 4 步：開始轉換

```
用戶點擊「開始轉換」
    ↓
setIsProcessing = true
isPausedRef.current = false
    ↓
processNext() 開始循環處理隊列
```

#### 第一個視頻：老電影.flv → 老電影.mp4

```
隊列狀態: [1] 老電影.flv - PROCESSING 🔄
    ↓
調用 window.electronAPI.convertVideo({
  inputPath: 'D:\影片\老電影.flv',
  outputPath: 'D:\轉換完成\老電影.mp4'
})
    ↓
main.js 接收 'convert-video' 命令
    ↓
[檢查點 1] ✅ 驗證路徑參數
    ↓
[檢查點 2] ✅ 文件存在且可讀
    ↓
[檢查點 3] ✅ 輸出目錄準備
    ↓
[檢查點 4] ✅ FFprobe 掃描
    視頻信息:
    - 時長: 600 秒
    - 分辨率: 720x480
    - 比特率: 800 kbps
    ↓
[檢查點 5] ✅ FFmpeg 開始轉碼
    進度更新:
    - 0 秒: 0%
    - 150 秒: 25%
    - 300 秒: 50%
    - 450 秒: 75%
    - 600 秒: 100% ✅
    (耗時: ~3 分鐘)
    ↓
[檢查點 6] ✅ 驗證輸出
    老電影.mp4 (125 MB) ✅
    ↓
隊列狀態: [1] 老電影.flv - COMPLETED ✅
    ↓
自動繼續下一個視頻
```

#### 第二個視頻：婚禮.wmv → 婚禮.mp4

```
隊列狀態: [2] 婚禮.wmv - PROCESSING 🔄
    ↓
(重複相同的 6 個檢查點)
    ↓
轉換耗時: ~4 分鐘
    ↓
隊列狀態: [2] 婚禮.wmv - COMPLETED ✅
```

#### 第三個視頻：短影片.3gp → 短影片.mp4

```
隊列狀態: [3] 短影片.3gp - PROCESSING 🔄
    ↓
(重複相同的 6 個檢查點)
    ↓
轉換耗時: ~30 秒
    ↓
隊列狀態: [3] 短影片.3gp - COMPLETED ✅
```

#### 轉換完成

```
所有隊列項目狀態:
[1] 老電影.flv - COMPLETED ✅
[2] 婚禮.wmv - COMPLETED ✅
[3] 短影片.3gp - COMPLETED ✅

輸出目錄 D:\轉換完成\ 中:
├── 老電影.mp4 ✅
├── 婚禮.mp4 ✅
└── 短影片.mp4 ✅

processNext() 檢測到沒有待處理項目，停止循環
isProcessing = false

UI 顯示: 全部轉換完成 ✅
```

### 總耗時

```
老電影轉換: 3 分鐘 (600 秒視頻 → ~3 倍速)
婚禮轉換: 4 分鐘 (2400 秒視頻 → ~10 倍速)
短影片轉換: 30 秒 (300 秒視頻 → ~10 倍速)

總計: 約 7-8 分鐘
```

---

## 日誌系統

### 為什麼需要日誌？

| 用途 | 說明 |
|------|------|
| **🐛 調試** | 出錯時有詳細記錄幫助排查問題 |
| **📊 監控** | 實時看到每一步進度 |
| **💾 存檔** | 保存到文件便於日後查閱 |
| **📱 用戶反饋** | 用戶遇到問題時有日誌可以提供 |

### 日誌位置

```
C:\Users\[用戶名]\.retro2mp4\logs\
├── conversion-2026-02-21T09-47-57.log
├── conversion-2026-02-21T10-30-45.log
└── ... (每次轉換創建新日誌)
```

### 日誌內容示例

```
[下午2:30:00] [IPC] ========== convert-video IPC 處理開始 ==========
[下午2:30:00] [IPC] 接收參數
{
  "inputPath": "D:\\影片\\老電影.flv",
  "outputPath": "D:\\轉換完成\\老電影.mp4"
}
[下午2:30:00] [IPC] 檢查點 1: 驗證輸入參數
[下午2:30:00] [IPC] 檢查點 2: 處理輸出路徑...

==================================================
轉換視頻文件開始
==================================================
[下午2:30:00] [VideoProcessor] 檢查點 1: 參數驗證
[下午2:30:00] [VideoProcessor] 檢查點 2: 檢查輸入文件...
[下午2:30:00] [VideoProcessor] ✅ 檢查點 2 通過: 輸入文件存在
[下午2:30:00] [VideoProcessor] 檢查點 3: 確保輸出目錄存在...
[下午2:30:00] [VideoProcessor] 檢查點 4: 使用 ffprobe 獲取影片資訊...
[下午2:30:00] [VideoProcessor] ✅ 檢查點 4 通過: ffprobe 完成
[下午2:30:01] [VideoProcessor] 檢查點 5: 啟動 FFmpeg 轉換...
[下午2:30:01] [VideoProcessor] ✅ 檢查點 5 通過: FFmpeg 進程已啟動
[下午2:30:45] [VideoProcessor] 進度: 50%
[下午2:33:15] [VideoProcessor] ✅ 檢查點 6: 轉換完成
[下午2:33:15] [VideoProcessor] 轉換耗時: 194.32 秒
```

---

## 常見問題

### Q1: 為什麼轉換很慢？

**A**: 這是正常的。FFmpeg 進行實時轉碼需要時間：
- 時長 10 分鐘的視頻 → 轉換需要 1-3 分鐘
- 取決於系統速度、視頻解析度、存儲速度

### Q2: 我可以邊轉邊停嗎？

**A**: 可以！點「暫停」停止當前轉換：
```
當前視頻暫停 → 後續視頻等待中
點「繼續」→ 從暫停的視頻繼續轉換
```

### Q3: 同時添加多個文件夾可以嗎？

**A**: 沒有直接支持，但可以：
1. 先掃描第一個資料夾
2. 轉換完成後
3. 再選擇第二個資料夾掃描
4. 或者把多個資料夾的視頻複製到一個文件夾中

### Q4: 轉換後的 MP4 格式是什麼？

**A**: 統一標準：
```
視頻: H.264 (高效、流播性好)
音頻: AAC (高品質、常用)
比特率: 根據原視頻自動調整
品質: CRF 22 (平衡品質和文件大小)
```

### Q5: 我可以同時掃描和轉換嗎？

**A**: 不建議。建議流程：
```
1. 掃描資料夾 (完成)
2. 檢查隊列
3. 開始轉換
4. 待轉換完成後再進行新的操作
```

---

## 技術檔案參考

### 使用的 npm 套件

```json
{
  "react": "^18.2.0",                    // UI 框架
  "electron": "^27.0.0",                 // 桌面應用
  "fluent-ffmpeg": "^2.1.2",             // FFmpeg 包裝器
  "ffmpeg-static": "^6.1.0",             // FFmpeg 二進制文件
  "ffprobe-static": "^3.1.0"             // FFprobe 二進制文件
}
```

### 主要文件

| 文件 | 用途 |
|------|------|
| `src/App.js` | 主應用組件，控制流程 |
| `electron/main.js` | Electron 主進程 |
| `electron/preload.js` | 安全 API 橋接 |
| `electron/videoProcessor.js` | 轉碼引擎 |
| `electron/logger.js` | 日誌系統 |

---

## 總結

這個視頻轉檔工具的核心就是：

```
用戶選擇視頻 → 前端發請求 → 後端調用 FFmpeg → 轉碼 → 返回結果 → 前端顯示進度
```

通過 **Electron 提供桌面環境**、**React 提供漂亮界面**、**FFmpeg 進行實際轉碼**、**IPC 實現前後端通信**，
形成一個完整的視頻轉檔解決方案。

希望這份技術指南幫您理解了整個系統的運作原理！
